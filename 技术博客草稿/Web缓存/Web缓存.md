---
layout: title
title: Web缓存
date: 2017-06-12 15:20:29
tags:

---

我们访问一个网站，总会经过客户端发起请求，请求到达服务器，服务器响应客户端并返回的请求资源内容这一过程。如果往后还要频繁访问该网站，而且该网站内容更新内容的频率很慢，我们每次访问到的都是相同资源，是不是依然要到服务器上请求这些资源？

<!--read more-->

## 什么是web缓存？

这里需要引入缓存的概念，保存资源的副本，下次访问无需从服务器端请求资源，直接取得该副本就行。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。

**缓存的好处**：

- 降低了加载时延，加快页面打开速度
- 减少网络带宽消耗
- 减少了冗余的数据传输，节省流量

在一个Web应用中，用到缓存的地方有很多，比如：**数据库数据缓存、代理服务器缓存、CDN缓存，以及浏览器缓存**。

## 浏览器缓存

|  规则  |  类型  |       消息报头        |    示例值     | 含义                                       |
| :--: | :--: | :---------------: | :--------: | :--------------------------------------- |
|      |  响应  |      Expires      |            | 告诉浏览器在过期时间前可以使用副本                        |
|      |  响应  |   Cache-Control   | max-age(秒) | 缓存的有效时长，表示从请求开始到过期时间之间的秒数                |
|      |      |                   |   public   |                                          |
|      |      |                   |  private   |                                          |
|      |      |                   |  no-cache  |                                          |
|      |      |                   |  no-store  |                                          |
|      |  响应  |   Last-Modified   |            | 告诉浏览器当前资源的最后修改时间                         |
|      |  请求  | If-Modified-Since |            | 如果浏览器第一次请求时响应中Last-Modified为空，第二次请求同一资源事，会把作为该项的值发给服务器 |
|      |  响应  |       ETag        |            | 当前资源在服务器中的唯一标识符（服务器端生成，生成规则由服务器决定）       |
|      |  请求  |   If-None-Match   |            | 如果浏览器第一次请求时响应中ETag为空，第二次请求同一资源事，会把作为该项的值发给服务器 |
|      |      |                   |            |                                          |
|      |      |                   |            |                                          |
|      |      |                   |            |                                          |
|      |      |                   |            |                                          |





缓存内容存放在浏览器端的有效时间，可以通过Cache-Control和Expires来决定。前者是HTTP1.0中的响应头，后者是HTTP1.1中新增的响应头，为了弥补Expires的缺陷而出现。

### Expires：



Expires设置的是过期的绝对时间，而客户端和服务器的时间通常会存在不同步的情况，容易导致误差，因此不推荐使用Expires。注意:**如果文中以下介绍的Cache-Control中设置了max-age，则会覆盖掉Expires。**

### Cache-Control:

Cache-Control中可以设置的属性有:max-age, public/private, no cache, no store.下面分别介绍:

1.max-age:单位为秒，表示在max-age定义的时间段内缓存有效，也就是说只要浏览器距离上次请求服务器的时间如果没有超过max-age，浏览器就不会向服务器发送请求了，而是直接从缓存中取信息了。max-ag=0或者是负值时，浏览器会在对应的缓存中把Expires设置为1970-01-01 08:00:00。

2.s-maxage:单位秒，类似于max-age ，但只适用于共享缓存。

3.public：副本存放在代理/公有缓存中，这样可以被多用户共享。没有明确指定为private时，默认为public。



4.private：只能缓存在本地浏览器中，通常在针对一些用户信息敏感的资源时使用。

5.no-store:禁止缓存任何资源，每次访问网站，都需要向服务器发送一次请求，每次都会下载完整的资源。通称用于机密性资源。

6.



======================================================

### Last-Modified & If-Modified-Since

Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。 

Last-Modified表示的是服务器端资源最后一次被修改的时间，需要和Cache-Control共同使用。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。

### ETag & If-None-Match

ETag & If-None-Match是一对报文头，属于http1.1。

客户端向服务器端第一次请求页面A，服务器接收到请求后会根据实体内容生成一段hash字符串或者说是实体标识（Entity Tag），来唯一标识该请求的资源，将页面A资源以及该标识发送给客户端；当下一次客户端再次请求页面A时，会连同ETAG一起发给服务器，服务器根据ETAG，检查页面A距上次请求后有没有被修改过，如果没有修改过，响应304让客户端用缓存中的内容渲染页面；如果修改过，则返回修改后的内容给客户端。

来个图呗

```sequence
客户端->服务器: 请求页面A
服务器-->客户端: 页面A+ETAG
客户端->服务器: 再次请求页面A+ETAG

```
=======================

服务器再验证：

有时候缓存资源已经过期了，但其实它和服务器端的资源并没有什么差别，只是由于到期了。



============================

参考链接：

[浅谈Web缓存](http://www.alloyteam.com/2016/03/discussion-on-web-caching/?utm_source=caibaojian.com)

[作为前端应当了解的Web缓存知识](http://www.cnblogs.com/dojo-lzz/p/5515839.html)

[Web前后端缓存技术](http://blog.csdn.net/leesirbupt/article/details/54409931)



